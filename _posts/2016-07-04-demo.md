
<!-- Reveal.js Configuration -->
<section>
    <h1>Detección y Corrección de Errores</h1>
    <h3>Fundamentos y Técnicas</h3>
</section>

<section>
    <h2>Importancia de la Precisión</h2>
    <p>
        <strong>Aplicaciones críticas</strong>: requieren alta precisión, como la transmisión de texto. <br>
        <strong>Aplicaciones tolerantes</strong>: como streaming de audio o video, pueden tolerar errores menores.
    </p>
</section>

<section>
    <h2>Tipos de Errores en la Transmisión</h2>
    <section>
        <h3>Error de Bit Único</h3>
        <p>Ocurre cuando un solo bit se altera.</p>
        <p><em>Ejemplo</em>: 00000010 (STX) se convierte en 00001010 (LF).</p>
    </section>
    <section>
        <h3>Error de Ráfaga</h3>
        <p>Cuando varios bits consecutivos se alteran.</p>
        <p><em>Ejemplo</em>: Un impulso de ruido que afecta múltiples bits.</p>
    </section>
</section>

<section>
    <h2>Concepto de Redundancia</h2>
    <p>La redundancia añade bits adicionales para detectar o corregir errores. Estos se añaden en el transmisor y se eliminan en el receptor.</p>
</section>

<section>
    <h2>Detección vs Corrección de Errores</h2>
    <section>
        <h3>Detección de Errores</h3>
        <p>Identifica si hay errores, pero no dónde o cuántos.</p>
    </section>
    <section>
        <h3>Corrección de Errores</h3>
        <p>Localiza y corrige errores específicos, pero requiere más bits redundantes.</p>
    </section>
</section>

<section>
    <h2>Métodos de Corrección de Errores</h2>
    <section>
        <h3>Corrección de Errores Adelantada (FEC)</h3>
        <p>Utiliza bits redundantes para corregir errores sin pedir retransmisiones.</p>
    </section>
    <section>
        <h3>Corrección por Retransmisión</h3>
        <p>El receptor detecta un error y solicita una nueva transmisión.</p>
    </section>
</section>

<section>
    <h2>Esquemas de Codificación y Redundancia</h2>
    <p>Los bits redundantes se generan mediante una relación matemática que permite la detección y corrección.</p>
</section>

<section>
    <h2>Codificación por Bloques</h2>
    <p>Divide los datos en bloques de <em>k bits</em> y añade <em>r bits</em> redundantes para formar bloques de <em>n bits</em>.</p>
    <p><em>Ejemplo</em>: C(n, k), con una distancia mínima de Hamming.</p>
</section>

<section>
    <h2>Distancia de Hamming</h2>
    <p>Medida de bits diferentes entre dos palabras de código.</p>
    <p><strong>Detección</strong>: d<sub>min</sub> ≥ s + 1 (para detectar s errores).</p>
    <p><strong>Corrección</strong>: d<sub>min</sub> suficiente para evitar confusiones.</p>
</section>

<section>
    <h2>Corrección de Errores y Geometría</h2>
    <p>Visualización geométrica: cada palabra de código tiene un territorio exclusivo que permite la corrección de errores.</p>
</section>

<section>
    <h2>Códigos Lineales por Bloques</h2>
    <p>Los códigos lineales simplifican el análisis porque la combinación (XOR) de palabras de código válidas sigue siendo válida.</p>
</section>

<section>
    <h2>Resumen</h2>
    <ul>
        <li><strong>Redundancia</strong>: Bits adicionales para detectar/corregir errores.</li>
        <li><strong>Codificación por Bloques</strong>: Bloques de datos con bits redundantes.</li>
        <li><strong>Distancia de Hamming</strong>: Clave para detectar/corregir errores.</li>
        <li><strong>Códigos Lineales</strong>: Simplifican la corrección de errores.</li>
    </ul>
</section>
